<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>对第一次面试知识点内容的总结和补充 - Z.H.</title><meta name="description" content="这是由第一次面试开始的第一篇Blog，写于最开始的开始 本次面试方向为Java架构方向，涉及到Java新的应用场景，相当于打开了Java的另一扇大门。由此开始了我的第一篇博客，对相关知识点和内容进行总结和实践。 其中包括如下知识点： Java中的Object类为所有类的父类，在Object下面包含了很多基础方法，譬如equals()、getClass()、hashCode()、toString()等。 hashCode()作为基础方法中重要的一员，用于返回对象的hash值，其返回值为int类型。 但是仅仅返回对象的hash值有什么意义吗？要想真正理解hashCode()方法的作用，必须要从hash散列和Java集合说起。&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><script type="text/javascript" async src="https://www.googletagmanager.com/gtag/js?id=6694651183"></script><script type="text/javascript">window.dataLayer = window.dataLayer || [];
				  function gtag(){dataLayer.push(arguments);}
				  gtag('js', new Date());
				  gtag('config', '6694651183' );
				  <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-NRGQEGZN7K"></script><script>window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-NRGQEGZN7K');</script><link rel="canonical" href="https://jobslee0.github.io/dui-di-yi-ci-mian-shi-zhi-shi-dian-nei-rong-de-zong-jie-he-bu-chong.html"><link rel="alternate" type="application/atom+xml" href="https://jobslee0.github.io/feed.xml"><link rel="alternate" type="application/json" href="https://jobslee0.github.io/feed.json"><meta property="og:title" content="对第一次面试知识点内容的总结和补充"><meta property="og:site_name" content="Z.H."><meta property="og:description" content="这是由第一次面试开始的第一篇Blog，写于最开始的开始 本次面试方向为Java架构方向，涉及到Java新的应用场景，相当于打开了Java的另一扇大门。由此开始了我的第一篇博客，对相关知识点和内容进行总结和实践。 其中包括如下知识点： Java中的Object类为所有类的父类，在Object下面包含了很多基础方法，譬如equals()、getClass()、hashCode()、toString()等。 hashCode()作为基础方法中重要的一员，用于返回对象的hash值，其返回值为int类型。 但是仅仅返回对象的hash值有什么意义吗？要想真正理解hashCode()方法的作用，必须要从hash散列和Java集合说起。&hellip;"><meta property="og:url" content="https://jobslee0.github.io/dui-di-yi-ci-mian-shi-zhi-shi-dian-nei-rong-de-zong-jie-he-bu-chong.html"><meta property="og:type" content="article"><link rel="shortcut icon" href="https://jobslee0.github.io/media/website/photo2pixel_download-2.png" type="image/x-icon"><link rel="preload" href="https://jobslee0.github.io/assets/dynamic/fonts/jetbrainsmono/jetbrainsmono.woff2" as="font" type="font/woff2" crossorigin><link rel="preload" href="https://jobslee0.github.io/assets/dynamic/fonts/jetbrainsmono/jetbrainsmono-italic.woff2" as="font" type="font/woff2" crossorigin><link rel="stylesheet" href="https://jobslee0.github.io/assets/css/style.css?v=82007ae11cb9f2a56571c770331b13e7"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://jobslee0.github.io/dui-di-yi-ci-mian-shi-zhi-shi-dian-nei-rong-de-zong-jie-he-bu-chong.html"},"headline":"对第一次面试知识点内容的总结和补充","datePublished":"2018-06-27T19:36","dateModified":"2024-09-26T22:56","description":"这是由第一次面试开始的第一篇Blog，写于最开始的开始 本次面试方向为Java架构方向，涉及到Java新的应用场景，相当于打开了Java的另一扇大门。由此开始了我的第一篇博客，对相关知识点和内容进行总结和实践。 其中包括如下知识点： Java中的Object类为所有类的父类，在Object下面包含了很多基础方法，譬如equals()、getClass()、hashCode()、toString()等。 hashCode()作为基础方法中重要的一员，用于返回对象的hash值，其返回值为int类型。 但是仅仅返回对象的hash值有什么意义吗？要想真正理解hashCode()方法的作用，必须要从hash散列和Java集合说起。&hellip;","author":{"@type":"Person","name":"Jobs.Lee","url":"https://jobslee0.github.io/authors/jobslee/"},"publisher":{"@type":"Organization","name":"Jobs.Lee"}}</script><noscript><style>img[loading] {
                    opacity: 1;
                }</style></noscript></head><body class="post-template"><div class="container container--center"><header class="header"><div class="header__logo"><a class="logo" href="https://jobslee0.github.io/">Z.H.</a></div></header><main class="content"><article class="post"><header><h1 class="post__title">对第一次面试知识点内容的总结和补充</h1><div class="post__meta"><time datetime="2018-06-27T19:36" class="post__date">六月 27, 2018 </time><span class="post__author"><a href="https://jobslee0.github.io/authors/jobslee/" class="feed__author">Jobs.Lee</a></span></div></header><div class="post__entry"><p></p><h1 id="这是由一次面试开始的第一篇blog">这是由第一次面试开始的第一篇Blog，写于最开始的开始</h1><br><p>本次面试方向为Java架构方向，涉及到Java新的应用场景，相当于打开了Java的另一扇大门。由此开始了我的第一篇博客，对相关知识点和内容进行总结和实践。</p><br><p>其中包括如下知识点：</p><br><ul><br><li><strong>Java中的hashCode()方法及相关应用</strong></li><br><li><strong>==和equal()的细节问题</strong></li><br><li><strong>jvm虚拟机内存结构</strong></li><br><li><strong>IO拥塞及5种IO模型</strong></li><br><li><strong>数据库分表分库</strong></li><br><li><strong>Redis缓存数据库</strong></li><br><li><strong>MyCat中间件</strong></li><br></ul><br><hr><br><ul><br><li>快捷目录</li></ul><div class="toc"><div class="toc"><br><ul><br><li><a href="#这是由一次面试开始的第一篇blog" rel="nofollow">这是由一次面试开始的第一篇Blog</a><br><ul><br><li><a href="#java中的hashcode方法及相关应用" rel="nofollow">Java中的hashCode()方法及相关应用</a></li><br><li><a href="#和equal的细节问题" rel="nofollow">==和equal()的细节问题</a></li><br><li><a href="#jvm虚拟机内存结构" rel="nofollow">jvm虚拟机内存结构</a></li><br><li><a href="#io拥塞及5种io模型" rel="nofollow">IO拥塞及5种IO模型</a></li><br><li><a href="#数据库分表分库" rel="nofollow">数据库分表分库</a></li><br><li><a href="#redis缓存数据库" rel="nofollow">Redis缓存数据库</a></li><br><li><a href="#mycat中间件" rel="nofollow">MyCat中间件</a></li></ul></li></ul></div></div><br><br><hr><br><h2 id="java中的hashcode方法及相关应用">Java中的hashCode()方法及相关应用</h2><br><p>Java中的Object类为所有类的父类，在Object下面包含了很多基础方法，譬如equals()、getClass()、hashCode()、toString()等。</p><br><p>hashCode()作为基础方法中重要的一员，用于返回对象的hash值，其返回值为int类型。</p><br><p>但是仅仅返回对象的hash值有什么意义吗？要想真正理解hashCode()方法的作用，必须要从hash散列和Java集合说起。</p><br><ul><br><li><p>hash散列：把任意长度的输入，通过散列算法变换成固定长度的输出，该输出就是散列值。通过散列计算地址来存储数据，再使用hash散列函数访问数据，能使对一个数据序列的访问过程更加迅速有效，数据元素将被更快地定位。hash算法会尽量选择更好的方案来减少碰撞，但在某些情况下，hash散列也会得出相同的值，此时便需要根据实际需要进行冲突的解决，因此，相同的hash值并不意味着目标对象是相同的。</p><br></li><br><li><p>Java集合：在Java中，HashMap是使用非常多的集合，它是基于哈希表的 Map 接口的实现，以key-value的形式存在，而HashSet仅存储对象，同时HashSet中不允许有重复的元素。当向一个Set集合中添加元素时，先调用这个元素的hashCode()方法，就能直接确定该元素的物理地址，当这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较；但是如果这个位置上已经有元素，就需要调用它的equals()方法与新元素进行比较，相同的话就不再存储，不相同就散列其它的地址。可以发现，在以上过程中涉及到equals()方法和hashCode()方法性能上的差距，Set集合在添加元素时，并没有直接通过equals()方法全权负责，而是先由hashCode()方法进行判断，再根据结果选择性调用equlas()方法。相关源代码如下：</p></li></ul><br><pre class="prettyprint"><code class="language-Java hljs cs"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span>(K key, V <span class="hljs-keyword">value</span>) {<br>        <span class="hljs-keyword">return</span> putVal(hash(key), key, <span class="hljs-keyword">value</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);<br>    }</code></pre><br><pre class="prettyprint"><code class="language-Java hljs cs">final V putVal(<span class="hljs-keyword">int</span> hash, K key, V <span class="hljs-keyword">value</span>, boolean onlyIfAbsent,<br>                   boolean evict) {<br>        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-keyword">int</span> n, i;<br>        <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>            n = (tab = resize()).length;<br>        <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-keyword">null</span>)<br>            tab[i] = newNode(hash, key, <span class="hljs-keyword">value</span>, <span class="hljs-keyword">null</span>);<br>        <span class="hljs-keyword">else</span> {<br>            Node&lt;K,V&gt; e; K k;<br>            <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;<br>                ((k = p.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br>                e = p;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p instanceof TreeNode)<br>                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-keyword">this</span>, tab, hash, key, <span class="hljs-keyword">value</span>);<br>            <span class="hljs-keyword">else</span> {<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> binCount = <span class="hljs-number">0</span>; ; ++binCount) {<br>                    <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-keyword">null</span>) {<br>                        p.next = newNode(hash, key, <span class="hljs-keyword">value</span>, <span class="hljs-keyword">null</span>);<br>                        <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>                            treeifyBin(tab, hash);<br>                        <span class="hljs-keyword">break</span>;<br>                    }<br>                    <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                        ((k = e.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br>                        <span class="hljs-keyword">break</span>;<br>                    p = e;<br>                }<br>            }<br>            <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) { <span class="hljs-comment">// existing mapping for key</span><br>                V oldValue = e.<span class="hljs-keyword">value</span>;<br>                <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-keyword">null</span>)<br>                    e.<span class="hljs-keyword">value</span> = <span class="hljs-keyword">value</span>;<br>                afterNodeAccess(e);<br>                <span class="hljs-keyword">return</span> oldValue;<br>            }<br>        }<br>        ++modCount;<br>        <span class="hljs-keyword">if</span> (++size &gt; threshold)<br>            resize();<br>        afterNodeInsertion(evict);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    }</code></pre><br><pre class="prettyprint"><code class="language-Java hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span>(E e) {<br>        <span class="hljs-keyword">return</span> map.put(e, PRESENT)==<span class="hljs-keyword">null</span>;<br>    }</code></pre><br><p>由此，可以总结如下：</p><br><ol><br><li>相同的对象具有相同的hash值</li><br><li>equals()相等的对象一定具有相同的hash值</li><br><li>hashCode()相同的对象不一定equals()相等</li><br><li>在比较场景下，hashCode()方法性能较equals()方法性能较好（一个用值来比较，一个用对象来比较）</li><br><li>hashCode()与equals()的重写问题：若重写了equals()方法，则有必要重写hashCode()方法(此处可以深入探讨)</li><br></ol><hr><br><h2 id="和equal的细节问题">==和equal()的细节问题</h2><br><p>equals()是java.lang.Object类的方法，要想说明==和equals()的区别，还要从代码开始：</p><br><pre class="prettyprint"><code class="language-Java hljs avrasm">        String str1, str2, str3 = <span class="hljs-string">"abc"</span>, str4 = <span class="hljs-string">"abc"</span><span class="hljs-comment">;</span><br>        str1 = new String(<span class="hljs-string">"abc"</span>)<span class="hljs-comment">;</span><br>        str2 = new String(<span class="hljs-string">"abc"</span>)<span class="hljs-comment">;</span><br>        StringBuffer strb1 = new StringBuffer(<span class="hljs-string">"abc"</span>)<span class="hljs-comment">;</span><br>        StringBuffer strb2 = new StringBuffer(<span class="hljs-string">"abc"</span>)<span class="hljs-comment">;</span><br><br>        System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(str1==str2)<span class="hljs-comment">;</span><br>        System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(str1<span class="hljs-preprocessor">.equals</span>(str2))<span class="hljs-comment">;</span><br>        System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(str3==str4)<span class="hljs-comment">;</span><br>        System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(str3<span class="hljs-preprocessor">.equals</span>(str4))<span class="hljs-comment">;</span><br>        System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(strb1==strb2)<span class="hljs-comment">;</span><br>        System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(strb1<span class="hljs-preprocessor">.equals</span>(strb2))<span class="hljs-comment">;</span></code></pre><br><p>控制台打印结果如下：</p><br><pre class="prettyprint"><code class="language-Java hljs bash"><span class="hljs-literal">false</span><br><span class="hljs-literal">true</span><br><span class="hljs-literal">true</span><br><span class="hljs-literal">true</span><br><span class="hljs-literal">false</span><br><span class="hljs-literal">false</span></code></pre><br><p>可是为什么会造成这样的结果呢，这就设计到==和equals()的一些细节问题。<br><br>经过查阅资料和源代码得知，==和equals()在比较上存在以下区别：</p><br><ol><br><li>“==”比较两个字符串变量本身的值，即两个对象在内存中的首地址</li><br><li>equals()比较字符串中所包含的内容是否相同，因为在String类中重写了equals()方法，比较的是字符串的内容而不是其地址，涉及到的源代码如下：</li></ol><br><pre class="prettyprint"><code class="language-Java hljs cs"><span class="hljs-keyword">public</span> boolean <span class="hljs-title">equals</span>(Object anObject) {<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == anObject) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        }<br>        <span class="hljs-keyword">if</span> (anObject instanceof String) {<br>            String anotherString = (String)anObject;<br>            <span class="hljs-keyword">int</span> n = <span class="hljs-keyword">value</span>.length;<br>            <span class="hljs-keyword">if</span> (n == anotherString.<span class="hljs-keyword">value</span>.length) {<br>                <span class="hljs-keyword">char</span> v1[] = <span class="hljs-keyword">value</span>;<br>                <span class="hljs-keyword">char</span> v2[] = anotherString.<span class="hljs-keyword">value</span>;<br>                <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">while</span> (n-- != <span class="hljs-number">0</span>) {<br>                    <span class="hljs-keyword">if</span> (v1[i] != v2[i])<br>                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                    i++;<br>                }<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    }</code></pre><br><ol><br><li>StringBuffer类中没有重新定义equals这个方法，因此这个方法就来自Object类，而Object类中的equals方法是用来比较地址的，所以等于false</li><br><li>对于str3和str4是由字符串生成的变量，因此所存放的内存地址是相同的</li></ol><br><p>下面再来测试一段代码：</p><br><pre class="prettyprint"><code class="language-Java hljs avrasm">        int i1 = <span class="hljs-number">1</span>, i2 = <span class="hljs-number">2</span>, i3 = <span class="hljs-number">1</span><span class="hljs-comment">;</span><br><br>        System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(i1==i2)<span class="hljs-comment">;</span><br>        System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(i1==i3)<span class="hljs-comment">;</span></code></pre><br><p>控制台输出结果如下：</p><br><pre class="prettyprint"><code class="language-Java hljs bash"><span class="hljs-literal">false</span><br><span class="hljs-literal">true</span></code></pre><br><p>由以上结论，可知==比较的是对象在内存中的首地址。这样以来可以说明jvm编译机制：int类型常量会根据大小区分指令，0~5一段，-128~127一段，-32768-32767一段，其余会作为常量放入常量池。其常量池的地址是相同的。</p><br><p>接下来再尝试下Integer类的情况：</p><br><pre class="prettyprint"><code class="language-Java hljs avrasm">        Integer ig1 = new Integer(<span class="hljs-number">123</span>)<span class="hljs-comment">;</span><br>        Integer ig2 = new Integer(<span class="hljs-number">123</span>)<span class="hljs-comment">;</span><br>        Integer ig3 = new Integer(<span class="hljs-number">321</span>)<span class="hljs-comment">;</span><br>        int i4 = ig3<span class="hljs-comment">;</span><br><br>        System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(ig1==ig2)<span class="hljs-comment">;</span><br>        System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(ig1==ig3)<span class="hljs-comment">;</span><br>        System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(ig1<span class="hljs-preprocessor">.equals</span>(ig2))<span class="hljs-comment">;</span><br>        System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(ig1<span class="hljs-preprocessor">.equals</span>(ig3))<span class="hljs-comment">;</span><br>        System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(ig3==i4)<span class="hljs-comment">;</span><br>        System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(ig3<span class="hljs-preprocessor">.equals</span>(i4))<span class="hljs-comment">;</span></code></pre><br><p>控制台输出显示如下：</p><br><pre class="prettyprint"><code class="language-Java hljs bash"><span class="hljs-literal">false</span><br><span class="hljs-literal">false</span><br><span class="hljs-literal">true</span><br><span class="hljs-literal">false</span><br><span class="hljs-literal">true</span><br><span class="hljs-literal">true</span></code></pre><br><p>可以发现，在Integer的实例下，==是比较地址的，而equals()是比较内容的。仔细查看源代码：</p><br><pre class="prettyprint"><code class="language-Java hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span>(Object obj) {<br>        <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> Integer) {<br>            <span class="hljs-keyword">return</span> value == ((Integer)obj).intValue();<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    }</code></pre><br><p>可见，Integer类重写了equals()方法，并且自动拆箱是调用Integer.valueOf()方法。</p><br><hr><br><h2 id="jvm虚拟机内存结构">jvm虚拟机内存结构</h2><br><p>由第二部分可知java代码在编译过程中涉及到内存机制问题，在这里简单设计下jvm虚拟机的内存结构。<br><br>借用下《深入理解Java虚拟机（第二版）》中的描述：</p><br><p><img loading="lazy" src="https://img-blog.csdn.net/20180627184150659?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FxaXUyMDE4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="jvm内存结构" data-is-external-image="true"></p><br><p>这里暂时作为参考和总结，具体细节比较复杂，在之后再做深入讨论。</p><br><hr><br><h2 id="io拥塞及5种io模型">IO拥塞及5种IO模型</h2><br><p>I/O：Input/Output 输入/输出<br><br>大致可分为内存IO、网络IO、磁盘IO</p><br><p>5种IO模型分别是阻塞IO模型、非阻塞IO模型、IO复用模型、信号驱动的IO模型、异步IO模型；前4种为同步IO操作，只有异步IO模型是异步IO操作。</p><br><p>此处参考大牛博客，对于消息同步异步以及IO模型进行了清晰和详细的阐述：</p><br><blockquote><br><p><a href="https://www.cnblogs.com/wxl-dede/p/5134636.html" rel="nofollow">https://www.cnblogs.com/wxl-dede/p/5134636.html</a></p></blockquote><br><hr><br><h2 id="数据库分表分库">数据库分表分库</h2><br><p>数据库分表分库思想，其英文名为Sharding，意为“分片”。</p><br><p>此处参考大牛博客，其全面的总结和中间件的汇总，让人十分受益：</p><br><blockquote><br><p><a href="https://www.cnblogs.com/jshen/p/7682502.html" rel="nofollow">https://www.cnblogs.com/jshen/p/7682502.html</a></p></blockquote><br><hr><br><h2 id="redis缓存数据库">Redis缓存数据库</h2><br><p>Redis 是一个高性能的key-value数据库。</p><br><blockquote><br><p>Redis 与其他 key - value 缓存产品有以下三个特点：</p><ul><br><li><p>Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用</p></li><br><li><p>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储</p></li><br><li><p>Redis支持数据的备份，即master-slave模式的数据备份</p></li></ul><br><p>Redis与其他key-value存储有什么不同？</p><ul><br><li><p>Redis有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象</p></li><br><li><p>Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。在内存数据库方面的另一个优点是，相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问</p></li></ul></blockquote><br><hr><br><h2 id="mycat中间件">MyCat中间件</h2><br><p>正如百度百科定义，MyCat是代替昂贵的oracle的MySQL集群中间件。</p><br><blockquote><br><p>Mycat的原理并不复杂，复杂的是代码，如果代码也不复杂，那么早就成为一个传说了</p><br><p>Mycat的原理中最重要的一个动词是“拦截”，它拦截了用户发送过来的SQL语句，首先对SQL语句做了一些特定的分析：如分片分析、路由分析、读写分离分析、缓存分析等，然后将此SQL发往后端的真实数据库，并将返回的结果做适当的处理，最终再返回给用户</p></blockquote><br><p>参考相关博客：</p><br><blockquote><br><p><a href="https://www.cnblogs.com/andy6/p/6622324.html" rel="nofollow">https://www.cnblogs.com/andy6/p/6622324.html</a></p></blockquote><br><hr><br><p><strong>其中内容有详有略，有些部分还需要不断地学习，先做引用之后会不断深入。记第一篇博客，加油！</strong></p><br><hr><br><p></p></div><footer class="wrapper post__footer"><p class="post__last-updated">This article was updated on 九月 26, 2024</p><div class="post__share"></div></footer></article></main><footer class="footer"><div class="footer__inner"><div class="footer__copyright"><p>© 2024 Powered by Publii CMS :: <a href="https://github.com/panr/hugo-theme-terminal" target="_blank" rel="noopener">Theme</a> ported by the <a href="https://getpublii.com/customization-service/" target="_blank" rel="noopener">Publii Team</a></p></div></div></footer></div><script defer="defer" src="https://jobslee0.github.io/assets/js/scripts.min.js?v=c2232aa7558e9517946129d2a1b8c770"></script><script>window.publiiThemeMenuConfig={mobileMenuMode:'sidebar',animationSpeed:300,submenuWidth: 'auto',doubleClickTime:500,mobileMenuExpandableSubmenus:true,relatedContainerForOverlayMenuSelector:'.top'};</script><script>var images = document.querySelectorAll('img[loading]');
        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>